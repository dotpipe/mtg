<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forge of Decks - MTG Synergy Builder</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Montserrat:wght@300;400;500;700&display=swap"
        rel="stylesheet">
    <style>
        /* ===== GLOBAL STYLES ===== */
        :root {
            --forge-red: #ff4b2b;
            --forge-orange: #ff9d2f;
            --forge-yellow: #ffcd38;
            --forge-dark: #1a1a1a;
            --forge-darker: #0a0a0a;
            --forge-light: #f5f5f5;
            --forge-accent: #7a3b2e;
            --card-width: 240px;
            --card-height: 336px;
            /* Standard MTG card ratio 63:88 */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            color: var(--forge-light);
            overflow-x: hidden;
            min-height: 100vh;
            background-image: url('https://images.unsplash.com/photo-1555505019-8c3f1c4aba5f?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            position: relative;
        }

        /* Semi-transparent white overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
            z-index: -1;
            backdrop-filter: blur(5px);
        }

        /* Dark overlay for better readability */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(10, 10, 10, 0.85) 0%, rgba(26, 26, 26, 0.75) 100%);
            z-index: -2;
        }

        h1,
        h2,
        h3,
        h4,
        h5 {
            font-family: 'Cinzel', serif;
            font-weight: 700;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            position: relative;
            z-index: 1;
        }

        /* ===== HEADER STYLES ===== */
        header {
            padding: 20px 0;
            position: relative;
            z-index: 10;
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 75, 43, 0.3);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        .logo img {
            width: 60px;
            height: 60px;
            margin-right: 15px;
            filter: drop-shadow(0 0 10px var(--forge-red));
        }

        .logo h1 {
            font-size: 2.5rem;
            background: linear-gradient(to right, var(--forge-red), var(--forge-orange), var(--forge-yellow));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        /* Animated sheen effect for logo */
        .logo::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(to right,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.3) 50%,
                    rgba(255, 255, 255, 0) 100%);
            transform: rotate(30deg);
            animation: sheen 6s infinite;
        }

        @keyframes sheen {
            0% {
                transform: rotate(30deg) translateX(-100%);
            }

            20%,
            100% {
                transform: rotate(30deg) translateX(100%);
            }
        }

        .nav-links {
            display: flex;
            gap: 20px;
        }

        .nav-links a {
            color: var(--forge-light);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
            position: relative;
            padding: 5px 0;
        }

        .nav-links a::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 2px;
            background: linear-gradient(to right, var(--forge-red), var(--forge-orange));
            transition: width 0.3s ease;
        }

        .nav-links a:hover {
            color: var(--forge-orange);
        }

        .nav-links a:hover::after {
            width: 100%;
        }

        /* ===== HERO SECTION ===== */
        .hero {
            height: 60vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(255, 75, 43, 0.2) 0%, rgba(10, 10, 10, 0) 70%);
            z-index: -1;
            animation: pulse 4s infinite alternate;
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
                transform: scale(1);
            }

            100% {
                opacity: 1;
                transform: scale(1.1);
            }
        }

        .hero h2 {
            font-size: 3.5rem;
            margin-bottom: 20px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .hero p {
            font-size: 1.2rem;
            max-width: 700px;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .hero-buttons {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .hero-btn {
            padding: 12px 25px;
            background: linear-gradient(135deg, var(--forge-red), var(--forge-accent));
            border: none;
            border-radius: 5px;
            color: var(--forge-light);
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .hero-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(122, 59, 46, 0.4);
        }

        /* ===== FORGE CENTERPIECE ===== */
        .forge-centerpiece {
            position: relative;
            width: 100%;
            height: 300px;
            margin: 50px 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .forge {
            position: relative;
            width: 400px;
            height: 250px;
            background: url('https://images.unsplash.com/photo-1554224155-1696413565d3?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80') center/cover;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            overflow: hidden;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .forge::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg,
                    rgba(255, 75, 43, 0.7) 0%,
                    rgba(255, 157, 47, 0.5) 50%,
                    rgba(255, 205, 56, 0.3) 100%);
            z-index: 1;
        }

        .forge::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80%;
            height: 40%;
            background: radial-gradient(ellipse at center, rgba(255, 205, 56, 0.8) 0%, rgba(255, 75, 43, 0) 70%);
            transform: translate(-50%, -30%);
            filter: blur(20px);
            z-index: 2;
            animation: flicker 3s infinite alternate;
        }

        @keyframes flicker {

            0%,
            100% {
                opacity: 1;
            }

            25% {
                opacity: 0.8;
            }

            50% {
                opacity: 0.9;
            }

            75% {
                opacity: 0.7;
            }
        }

        .forge-sparks {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }

        .spark {
            position: absolute;
            width: 3px;
            height: 3px;
            background-color: var(--forge-yellow);
            border-radius: 50%;
            opacity: 0;
            animation: spark-fly 2s ease-out infinite;
        }

        @keyframes spark-fly {
            0% {
                transform: translateY(100px) translateX(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-100px) translateX(var(--x-offset));
                opacity: 0;
            }
        }

        .forge-title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 4;
            text-align: center;
            width: 100%;
        }

        .forge-title h3 {
            font-size: 2.5rem;
            color: var(--forge-light);
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.7);
            margin-bottom: 15px;
        }

        /* ===== DECK BUILDER INTERFACE ===== */
        .deck-builder-interface {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 50px 0;
        }

        @media (max-width: 992px) {
            .deck-builder-interface {
                grid-template-columns: 1fr;
            }
        }

        /* ===== CARD SELECTION PANEL ===== */
        .card-selection-panel {
            background: rgba(26, 26, 26, 0.7);
            padding: 30px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 75, 43, 0.3);
            padding-bottom: 15px;
        }

        .panel-title {
            font-size: 1.5rem;
            color: var(--forge-light);
        }

        .search-bar {
            display: flex;
            margin-bottom: 20px;
            position: relative;
        }

        .search-bar input {
            flex: 1;
            padding: 12px 15px;
            background: rgba(10, 10, 10, 0.6);
            border: 1px solid var(--forge-accent);
            border-radius: 5px 0 0 5px;
            color: var(--forge-light);
            font-family: 'Montserrat', sans-serif;
        }

        .search-bar button {
            padding: 12px 20px;
            background: linear-gradient(135deg, var(--forge-red), var(--forge-accent));
            border: none;
            border-radius: 0 5px 5px 0;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .search-bar button:hover {
            background: linear-gradient(135deg, var(--forge-orange), var(--forge-red));
        }

        /* Format selection */
        .format-selection {
            margin-bottom: 20px;
        }

        .format-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .format-btn {
            padding: 8px 15px;
            background: linear-gradient(135deg, var(--forge-dark), var(--forge-darker));
            border: 1px solid var(--forge-accent);
            border-radius: 5px;
            color: var(--forge-light);
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .format-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .format-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(122, 59, 46, 0.4);
        }

        .format-btn:hover::before {
            left: 100%;
        }

        .format-btn.active {
            background: linear-gradient(135deg, var(--forge-red), var(--forge-accent));
            box-shadow: 0 5px 15px rgba(122, 59, 46, 0.6);
        }

        /* Filter options */
        .filter-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        .filter-group {
            flex: 1;
            min-width: 150px;
        }

        .filter-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .filter-group select,
        .filter-group input {
            width: 100%;
            padding: 8px 12px;
            background: rgba(10, 10, 10, 0.6);
            border: 1px solid var(--forge-accent);
            border-radius: 5px;
            color: var(--forge-light);
            font-family: 'Montserrat', sans-serif;
        }

        /* Card grid */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            max-height: 500px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .card-grid::-webkit-scrollbar {
            width: 8px;
        }

        .card-grid::-webkit-scrollbar-track {
            background: rgba(10, 10, 10, 0.3);
            border-radius: 4px;
        }

        .card-grid::-webkit-scrollbar-thumb {
            background: var(--forge-accent);
            border-radius: 4px;
        }

        .card-grid::-webkit-scrollbar-thumb:hover {
            background: var(--forge-red);
        }

        .card-container {
            position: relative;
            width: 100%;
            padding-bottom: 140%;
            /* Maintain card aspect ratio */
            perspective: 1000px;
        }

        .card {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 4.5% / 3.5%;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.165, 0.84, 0.44, 1);
            cursor: pointer;
            background-color: var(--forge-dark);
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-10px) rotateX(5deg) rotateY(-5deg);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.6);
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.1) 50%,
                    rgba(255, 255, 255, 0) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2;
            pointer-events: none;
        }

        .card:hover::before {
            opacity: 1;
            animation: card-shine 1.5s ease-in-out;
        }

        @keyframes card-shine {
            0% {
                transform: translateY(100%) translateX(-100%);
            }

            100% {
                transform: translateY(-100%) translateX(100%);
            }
        }

        .card-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 4.5% / 3.5%;
        }

        .card-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
            color: var(--forge-light);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 3;
        }

        .card:hover .card-overlay {
            opacity: 1;
            transform: translateY(0);
        }

        .card-name {
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-type {
            font-size: 0.7rem;
            opacity: 0.8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
        }

        .card-btn {
            padding: 5px 10px;
            background: rgba(255, 75, 43, 0.7);
            border: none;
            border-radius: 3px;
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            transition: background 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .card-btn:hover {
            background: rgba(255, 75, 43, 1);
        }

        /* Button sheen effect */
        .card-btn::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(to right,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.3) 50%,
                    rgba(255, 255, 255, 0) 100%);
            transform: rotate(30deg) translateX(-100%);
            animation: button-sheen 3s infinite;
        }

        @keyframes button-sheen {
            0% {
                transform: rotate(30deg) translateX(-100%);
            }

            20%,
            100% {
                transform: rotate(30deg) translateX(100%);
            }
        }

        .card.selected {
            box-shadow: 0 0 0 3px var(--forge-yellow), 0 10px 20px rgba(0, 0, 0, 0.4);
        }

        .card.selected::after {
            content: '✓';
            position: absolute;
            top: 10px;
            right: 10px;
            width: 25px;
            height: 25px;
            background: var(--forge-yellow);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--forge-dark);
            font-weight: bold;
            z-index: 4;
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            gap: 10px;
        }

        .pagination-btn {
            padding: 8px 15px;
            background: rgba(10, 10, 10, 0.6);
            border: 1px solid var(--forge-accent);
            border-radius: 5px;
            color: var(--forge-light);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .pagination-btn:hover {
            background: var(--forge-accent);
        }

        .pagination-btn.active {
            background: linear-gradient(135deg, var(--forge-red), var(--forge-accent));
        }

        /* ===== DECK BUILDER PANEL ===== */
        .deck-builder-panel {
            background: rgba(26, 26, 26, 0.7);
            padding: 30px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        .deck-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 75, 43, 0.3);
            padding-bottom: 15px;
        }

        .deck-title {
            font-size: 1.5rem;
            color: var(--forge-light);
        }

        .deck-name-input {
            display: flex;
            margin-bottom: 20px;
        }

        .deck-name-input input {
            flex: 1;
            padding: 10px 15px;
            background: rgba(10, 10, 10, 0.6);
            border: 1px solid var(--forge-accent);
            border-radius: 5px;
            color: var(--forge-light);
            font-family: 'Montserrat', sans-serif;
        }

        .deck-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .stat-box {
            background: rgba(10, 10, 10, 0.6);
            padding: 10px 15px;
            border-radius: 5px;
            text-align: center;
            flex: 1;
            min-width: 80px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--forge-orange);
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .deck-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 75, 43, 0.3);
        }

        .deck-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: var(--forge-light);
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            position: relative;
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        .deck-tab::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 0;
            height: 2px;
            background: linear-gradient(to right, var(--forge-red), var(--forge-orange));
            transition: width 0.3s ease;
        }

        .deck-tab:hover {
            opacity: 1;
        }

        .deck-tab.active {
            opacity: 1;
        }

        .deck-tab.active::after {
            width: 100%;
        }

        .deck-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }

        .deck-content::-webkit-scrollbar {
            width: 8px;
        }

        .deck-content::-webkit-scrollbar-track {
            background: rgba(10, 10, 10, 0.3);
            border-radius: 4px;
        }

        .deck-content::-webkit-scrollbar-thumb {
            background: var(--forge-accent);
            border-radius: 4px;
        }

        .deck-content::-webkit-scrollbar-thumb:hover {
            background: var(--forge-red);
        }

        .deck-section {
            margin-bottom: 20px;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section-title {
            font-size: 1.1rem;
            color: var(--forge-orange);
        }

        .section-count {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .deck-cards {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .deck-card {
            display: flex;
            align-items: center;
            background: rgba(10, 10, 10, 0.6);
            padding: 8px 12px;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .deck-card:hover {
            background: rgba(10, 10, 10, 0.8);
            transform: translateY(-2px);
        }

        .card-quantity {
            width: 25px;
            text-align: center;
            font-weight: 700;
            color: var(--forge-orange);
            margin-right: 10px;
        }

        .quantity-controls {
            display: flex;
            flex-direction: column;
            margin-right: 10px;
        }

        .quantity-btn {
            background: none;
            border: none;
            color: var(--forge-light);
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .quantity-btn:hover {
            opacity: 1;
        }

        .card-info {
            flex: 1;
        }

        .card-name {
            font-weight: 500;
            margin-bottom: 3px;
        }

        .card-type {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .card-cost {
            margin-right: 10px;
            font-weight: 700;
            color: var(--forge-light);
        }

        .remove-card {
            background: none;
            border: none;
            color: var(--forge-red);
            cursor: pointer;
            font-size: 1.2rem;
            transition: color 0.3s ease;
            padding: 0 5px;
        }

        .remove-card:hover {
            color: var(--forge-orange);
        }

        .deck-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            gap: 10px;
        }

        .deck-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--forge-red), var(--forge-accent));
            border: none;
            border-radius: 5px;
            color: white;
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .deck-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(122, 59, 46, 0.4);
        }

        /* Button sheen effect */
        .deck-btn::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(to right,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.2) 50%,
                    rgba(255, 255, 255, 0) 100%);
            transform: rotate(30deg) translateX(-100%);
            animation: button-sheen 4s infinite;
        }

        /* ===== SYNERGY DISPLAY ===== */
        .synergy-display {
            background: rgba(26, 26, 26, 0.7);
            padding: 30px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            margin-top: 30px;
        }

        .synergy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 75, 43, 0.3);
            padding-bottom: 15px;
        }

        .synergy-title {
            font-size: 1.5rem;
            color: var(--forge-light);
        }

        .synergy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
        }

        .synergy-card {
            background: rgba(10, 10, 10, 0.6);
            border-radius: 5px;
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
        }

        .synergy-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
        }

        .synergy-card-image {
            width: 100%;
            aspect-ratio: 63/88;
            object-fit: cover;
        }

        .synergy-card-info {
            padding: 10px;
        }

        .synergy-card-name {
            font-weight: 500;
            margin-bottom: 3px;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .synergy-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 5px;
        }

        .synergy-stars {
            color: var(--forge-yellow);
            font-size: 0.9rem;
        }

        .synergy-percentage {
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--forge-orange);
        }

        .synergy-type {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--forge-yellow);
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 10px;
            text-transform: capitalize;
        }

        .add-synergy-btn {
            width: 100%;
            padding: 8px 0;
            background: rgba(255, 75, 43, 0.7);
            border: none;
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .add-synergy-btn:hover {
            background: rgba(255, 75, 43, 1);
        }

        /* ===== MANA CURVE CHART ===== */
        .mana-curve {
            margin-top: 30px;
        }

        .mana-curve-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--forge-light);
        }

        .curve-container {
            display: flex;
            align-items: flex-end;
            height: 150px;
            gap: 5px;
            padding-bottom: 25px;
            position: relative;
        }

        .curve-bar {
            flex: 1;
            background: linear-gradient(to top, var(--forge-accent), var(--forge-red));
            min-width: 30px;
            border-radius: 3px 3px 0 0;
            position: relative;
            transition: height 0.3s ease;
        }

        .curve-bar-label {
            position: absolute;
            bottom: -25px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
        }

        .curve-bar-count {
            position: absolute;
            top: -20px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--forge-yellow);
        }

        /* ===== COLOR DISTRIBUTION ===== */
        .color-distribution {
            margin-top: 30px;
        }

        .color-distribution-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--forge-light);
        }

        .color-pips {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .color-pip {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: 700;
            position: relative;
        }

        .color-pip-count {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--forge-dark);
            color: var(--forge-light);
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem;
            border: 1px solid var(--forge-accent);
        }

        .color-W {
            background: #f8f6d8;
            color: #211d15;
        }

        .color-U {
            background: #0e68ab;
            color: white;
        }

        .color-B {
            background: #150b00;
            color: white;
        }

        .color-R {
            background: #d3202a;
            color: white;
        }

        .color-G {
            background: #00733e;
            color: white;
        }

        .color-C {
            background: #ccc;
            color: #333;
        }

        /* ===== LOADING OVERLAY ===== */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid transparent;
            border-top-color: var(--forge-red);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-spinner::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: 5px solid transparent;
            border-top-color: var(--forge-orange);
            border-radius: 50%;
            animation: spin 2s linear infinite;
        }

        .loading-spinner::after {
            content: '';
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            bottom: 15px;
            border: 5px solid transparent;
            border-top-color: var(--forge-yellow);
            border-radius: 50%;
            animation: spin 1.5s linear infinite reverse;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* ===== NOTIFICATION SYSTEM ===== */
        .notification-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .notification {
            background: rgba(26, 26, 26, 0.9);
            color: var(--forge-light);
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 300px;
            max-width: 400px;
            animation: slide-in 0.3s ease-out;
        }

        .notification.success {
            border-left: 4px solid #2ecc71;
        }

        .notification.error {
            border-left: 4px solid #e74c3c;
        }

        .notification.info {
            border-left: 4px solid #3498db;
        }

        .notification-icon {
            font-size: 1.5rem;
        }

        .notification-content {
            flex: 1;
        }

        .notification-close {
            background: none;
            border: none;
            color: var(--forge-light);
            cursor: pointer;
            font-size: 1.2rem;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .notification-close:hover {
            opacity: 1;
        }

        @keyframes slide-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification.fade-out {
            animation: fade-out 0.3s ease-in forwards;
        }

        @keyframes fade-out {
            from {
                transform: translateX(0);
                opacity: 1;
            }

            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* ===== RESPONSIVE STYLES ===== */
        @media (max-width: 1200px) {
            .synergy-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .deck-builder-interface {
                grid-template-columns: 1fr;
            }

            .hero h2 {
                font-size: 2.5rem;
            }

            .forge {
                width: 300px;
                height: 200px;
            }

            .forge-title h3 {
                font-size: 2rem;
            }

            .deck-stats {
                flex-direction: column;
            }

            .synergy-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
        }

        @media (max-width: 576px) {
            .hero h2 {
                font-size: 2rem;
            }

            .forge {
                width: 250px;
                height: 160px;
            }

            .forge-title h3 {
                font-size: 1.5rem;
            }

            .format-buttons {
                flex-direction: column;
            }

            .deck-actions {
                flex-direction: column;
            }

            .synergy-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
        }
    </style>
</head>

<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
    </div>

    <!-- Header -->
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <img src="https://cdn-icons-png.flaticon.com/512/1067/1067357.png" alt="Forge Logo">
                    <h1>Forge of Decks</h1>
                </div>
                <nav class="nav-links">
                    <a href="#" class="active">Synergy Builder</a>
                    <a href="#">Collection</a>
                    <a href="#">Decks</a>
                    <a href="#">About</a>
                </nav>
            </div>
        </div>
    </header>

    <!-- Hero Section -->
    <section class="hero">
        <div class="container">
            <h2>Forge Your Perfect Deck</h2>
            <p>Discover powerful card synergies, build optimized decks, and dominate your next game with our advanced
                MTG synergy engine.</p>
        </div>
    </section>

    <!-- Forge Centerpiece -->
    <section class="forge-centerpiece">
        <div class="container">
            <div class="forge">
                <div class="forge-sparks" id="forge-sparks"></div>
                <div class="forge-title">
                    <h3>Select Your Centerpiece</h3>
                </div>
            </div>
        </div>
    </section>

    <!-- Deck Builder Interface -->
    <section class="container">
        <div class="deck-builder-interface">
            <!-- Card Selection Panel -->
            <div class="card-selection-panel">
                <div class="panel-header">
                    <h3 class="panel-title">Card Selection</h3>
                </div>

                <div class="search-bar">
                    <input type="text" id="card-search" placeholder="Search for cards...">
                    <button id="search-btn">Search</button>
                </div>

                <div class="format-selection">
                    <div class="format-buttons">
                        <button class="format-btn active" data-format="standard">Standard</button>
                        <button class="format-btn" data-format="modern">Modern</button>
                        <button class="format-btn" data-format="commander">Commander</button>
                        <button class="format-btn" data-format="pioneer">Pioneer</button>
                        <button class="format-btn" data-format="legacy">Legacy</button>
                    </div>
                </div>

                <div class="filter-options">
                    <div class="filter-group">
                        <label for="min-synergy">Min Synergy</label>
                        <select id="min-synergy">
                            <option value="0.1">1+ Stars</option>
                            <option value="0.2">2+ Stars</option>
                            <option value="0.3" selected>3+ Stars</option>
                            <option value="0.4">4+ Stars</option>
                            <option value="0.5">5 Stars Only</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="card-type">Card Type</label>
                        <select id="card-type">
                            <option value="">All Types</option>
                            <option value="creature">Creatures</option>
                            <option value="instant">Instants</option>
                            <option value="sorcery">Sorceries</option>
                            <option value="artifact">Artifacts</option>
                            <option value="enchantment">Enchantments</option>
                            <option value="planeswalker">Planeswalkers</option>
                            <option value="land">Lands</option>
                        </select>
                    </div>
                </div>

                <div class="card-grid" id="card-grid">
                    <!-- Cards will be dynamically loaded here -->
                </div>

                <div class="pagination" id="pagination">
                    <!-- Pagination will be dynamically generated -->
                </div>
            </div>

            <!-- Loading Overlay with cancel button -->
            <div class="loading-overlay" id="loading-overlay">
                <div class="loading-spinner"></div>
                <p style="color: white; margin-top: 20px;">Loading...</p>
                <button id="cancel-loading"
                    style="margin-top: 20px; padding: 8px 16px; background: rgba(255,75,43,0.7); border: none; color: white; border-radius: 4px; cursor: pointer;">
                    Cancel
                </button>
            </div>

            <!-- Deck Builder Panel -->
            <div class="deck-builder-panel">
                <div class="deck-header">
                    <h3 class="deck-title">Your Deck</h3>
                </div>

                <div class="deck-name-input">
                    <input type="text" id="deck-name" placeholder="Enter deck name...">
                </div>

                <div class="deck-stats">
                    <div class="stat-box">
                        <div class="stat-value" id="card-count">0</div>
                        <div class="stat-label">Cards</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="avg-cmc">0.0</div>
                        <div class="stat-label">Avg CMC</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="synergy-score">0</div>
                        <div class="stat-label">Synergy</div>
                    </div>
                </div>

                <div class="deck-tabs">
                    <button class="deck-tab active" data-tab="all">All Cards</button>
                    <button class="deck-tab" data-tab="creatures">Creatures</button>
                    <button class="deck-tab" data-tab="spells">Spells</button>
                    <button class="deck-tab" data-tab="lands">Lands</button>
                </div>

                <div class="deck-content" id="deck-content">
                    <!-- Deck cards will be dynamically loaded here -->
                    <p id="empty-deck-message">Select a centerpiece card to begin building your deck.</p>
                </div>

                <div class="mana-curve">
                    <h4 class="mana-curve-title">Mana Curve</h4>
                    <div class="curve-container" id="mana-curve">
                        <!-- Mana curve will be dynamically generated -->
                    </div>
                </div>

                <div class="color-distribution">
                    <h4 class="color-distribution-title">Color Distribution</h4>
                    <div class="color-pips" id="color-pips">
                        <!-- Color pips will be dynamically generated -->
                    </div>
                </div>

                <div class="deck-actions">
                    <button class="deck-btn" id="build-deck-btn">Auto-Build Deck</button>
                    <button class="deck-btn" id="analyze-deck-btn">Analyze Synergies</button>
                    <button class="deck-btn" id="save-deck-btn">Save Deck</button>
                    <button class="deck-btn" id="clear-deck-btn">Clear Deck</button>
                </div>
            </div>
        </div>

        <!-- Synergy Display -->
        <div class="synergy-display" id="synergy-display">
            <div class="synergy-header">
                <h3 class="synergy-title">Card Synergies</h3>
            </div>
            <div class="synergy-grid" id="synergy-grid">
                <!-- Synergy cards will be dynamically loaded here -->
            </div>
        </div>
    </section>

    <!-- Notification Container -->
    <div class="notification-container" id="notification-container"></div>
    <script>
        // Immediate fix for persistent loading spinner
        document.addEventListener('DOMContentLoaded', function () {
            // Hide loading overlay after a short delay
            setTimeout(function () {
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                    console.log('Loading overlay forcibly hidden');
                }

                // Load demo cards if the card grid is empty
                const cardGrid = document.getElementById('card-grid');
                if (cardGrid && (!cardGrid.children || cardGrid.children.length === 0)) {
                    loadDemoCards();
                }
            }, 2000); // 2 seconds delay
        });

        // Simple demo card loader
        function loadDemoCards() {
            const cardGrid = document.getElementById('card-grid');
            if (!cardGrid) return;

            const demoCards = [
                {
                    name: "Chandra, Torch of Defiance",
                    type: "Legendary Planeswalker — Chandra",
                    image: "https://c1.scryfall.com/file/scryfall-cards/normal/front/f/f/ff8086cd-b868-4f4e-823e-2635ad7ebc07.jpg"
                },
                {
                    name: "Goldspan Dragon",
                    type: "Creature — Dragon",
                    image: "https://c1.scryfall.com/file/scryfall-cards/normal/front/9/d/9d914868-9000-4df2-a818-0ef8a7f636ae.jpg"
                },
                {
                    name: "Lightning Bolt",
                    type: "Instant",
                    image: "https://c1.scryfall.com/file/scryfall-cards/normal/front/f/2/f29ba16f-c8fb-42fe-aabf-87089cb214a7.jpg"
                },
                {
                    name: "Mountain",
                    type: "Basic Land — Mountain",
                    image: "https://c1.scryfall.com/file/scryfall-cards/normal/front/b/8/b86fbf78-57ec-4a0f-9fb6-e4bf0cbc9315.jpg"
                }
            ];

            cardGrid.innerHTML = '';

            demoCards.forEach(card => {
                const cardContainer = document.createElement('div');
                cardContainer.className = 'card-container';

                cardContainer.innerHTML = `
                <div class="card">
                    <img class="card-image" src="${card.image}" alt="${card.name}">
                    <div class="card-overlay">
                        <div class="card-name">${card.name}</div>
                        <div class="card-type">${card.type}</div>
                        <div class="card-actions">
                            <button class="card-btn">Add to Deck</button>
                            <button class="card-btn">Synergies</button>
                        </div>
                    </div>
                </div>
            `;

                cardGrid.appendChild(cardContainer);
            });
        }
    </script>


    <script>
        // Global state
        const state = {
            selectedCard: null,
            deck: {
                cards: {},
                commander: null,
                name: '',
                format: 'standard'
            },
            currentTab: 'all',
            loading: false,
            apiBaseUrl: './',  // Base URL for API endpoints
            debugMode: true    // Enable debug mode to log API responses
        };

        // Check API availability
        async function checkApiAvailability() {
            let api1Available = false;
            let api2Available = false;

            try {
                await fetch('api.php?action=ping', { method: 'HEAD' });
                api1Available = true;
            } catch (error) {
                console.warn('api.php is not available:', error);
            }

            try {
                await fetch('api2.php?action=ping', { method: 'HEAD' });
                api2Available = true;
            } catch (error) {
                console.warn('api2.php is not available:', error);
            }

            if (!api1Available && !api2Available) {
                showNotification('API services are not available. Using demo mode.', 'error');
                state.apiMode = 'demo';
            } else {
                state.apiMode = 'online';
                if (!api2Available) {
                    showNotification('Enhanced API is not available. Some features may be limited.', 'info');
                }
            }

            return { api1Available, api2Available };
        }

        // Initialize the application with API availability check
        document.addEventListener('DOMContentLoaded', async () => {
            // Check API availability first
            const { api1Available, api2Available } = await checkApiAvailability();

            // Initialize the app
            initializeForge();
            setupEventListeners();
            registerServiceWorker();

            // Load initial cards based on API availability
            if (api1Available || api2Available) {
                loadInitialCards();
            } else {
                loadDemoCards();
            }
        });

        // Add event listener for cancel button
        document.getElementById('cancel-loading').addEventListener('click', () => {
            setLoading(false);
            showNotification('Loading cancelled by user', 'info');
        });


        // DOM Elements
        const elements = {
            cardGrid: document.getElementById('card-grid'),
            pagination: document.getElementById('pagination'),
            deckContent: document.getElementById('deck-content'),
            emptyDeckMessage: document.getElementById('empty-deck-message'),
            cardCount: document.getElementById('card-count'),
            avgCmc: document.getElementById('avg-cmc'),
            synergyScore: document.getElementById('synergy-score'),
            manaCurve: document.getElementById('mana-curve'),
            colorPips: document.getElementById('color-pips'),
            synergyGrid: document.getElementById('synergy-grid'),
            loadingOverlay: document.getElementById('loading-overlay'),
            notificationContainer: document.getElementById('notification-container'),
            forgeTitle: document.querySelector('.forge-title h3'),
            forgeSparks: document.getElementById('forge-sparks'),
            cancelLoading: document.getElementById('cancel-loading')
        };

        // Initialize the application with API availability check
        document.addEventListener('DOMContentLoaded', async () => {
            // Add cancel button to loading overlay if it doesn't exist
            if (!elements.cancelLoading) {
                const cancelBtn = document.createElement('button');
                cancelBtn.id = 'cancel-loading';
                cancelBtn.textContent = 'Cancel';
                cancelBtn.style.marginTop = '20px';
                cancelBtn.style.padding = '8px 16px';
                cancelBtn.style.background = 'rgba(255,75,43,0.7)';
                cancelBtn.style.border = 'none';
                cancelBtn.style.color = 'white';
                cancelBtn.style.borderRadius = '4px';
                cancelBtn.style.cursor = 'pointer';

                cancelBtn.addEventListener('click', () => {
                    setLoading(false);
                    showNotification('Loading cancelled by user', 'info');
                });

                elements.loadingOverlay.appendChild(cancelBtn);
                elements.cancelLoading = cancelBtn;
            }

            // Check API availability first
            const { api1Available, api2Available } = await checkApiAvailability();

            // Initialize the app
            initializeForge();
            setupEventListeners();
            registerServiceWorker();

            // Load initial cards based on API availability
            if (api1Available || api2Available) {
                loadInitialCards();
            } else {
                loadDemoCards();
                showNotification('Running in demo mode. API services are not available.', 'info');
            }
        });

        // Check API availability
        async function checkApiAvailability() {
            let api1Available = false;
            let api2Available = false;

            try {
                const response = await fetch('api.php?action=ping', {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' },
                    mode: 'no-cors'
                });
                api1Available = true;
                console.log('api.php is available');
            } catch (error) {
                console.warn('api.php is not available:', error);
            }

            try {
                const response = await fetch('api2.php?action=ping', {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' },
                    mode: 'no-cors'
                });
                api2Available = true;
                console.log('api2.php is available');
            } catch (error) {
                console.warn('api2.php is not available:', error);
            }

            if (!api1Available && !api2Available) {
                state.apiMode = 'demo';
            } else {
                state.apiMode = 'online';
            }

            return { api1Available, api2Available };
        }

        // Enhanced API fetch function with timeout and better error handling
        async function apiRequest(endpoint, options = {}) {
            try {
                setLoading(true);

                // If in demo mode, immediately return demo data
                if (state.apiMode === 'demo') {
                    throw new Error('API is in demo mode');
                }

                // Default options
                const defaultOptions = {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    timeout: 10000 // 10 second timeout
                };

                // Merge options
                const fetchOptions = { ...defaultOptions, ...options };

                // Create an abort controller for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), fetchOptions.timeout);

                // Log request in debug mode
                if (state.debugMode) {
                    console.log(`API Request: ${endpoint}`, fetchOptions);
                }

                try {
                    // Make the request with timeout
                    const response = await fetch(endpoint, {
                        ...fetchOptions,
                        signal: controller.signal
                    });

                    // Clear timeout
                    clearTimeout(timeoutId);

                    // Check if response is ok
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    // Get response text first to check if it's valid JSON
                    const responseText = await response.text();

                    // Log raw response in debug mode
                    if (state.debugMode) {
                        console.log(`API Response (raw): ${responseText}`);
                    }

                    // Try to parse as JSON
                    let data;
                    try {
                        data = JSON.parse(responseText);
                    } catch (e) {
                        console.error('Invalid JSON response:', responseText);
                        throw new Error('Invalid JSON response from server');
                    }

                    // Check for API error
                    if (data && data.error) {
                        throw new Error(data.error);
                    }

                    return data;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Request timed out');
                    }
                    throw error;
                }
            } catch (error) {
                console.error('API Request Error:', error);
                throw error;
            } finally {
                // Always ensure loading is set to false
                setLoading(false);
            }
        }

        // Enhanced setLoading function with debug info and timeout
        function setLoading(isLoading) {
            const prevState = state.loading;
            state.loading = isLoading;
            elements.loadingOverlay.style.display = isLoading ? 'flex' : 'none';

            // Log state change
            console.log(`Loading state changed: ${prevState} -> ${isLoading}`);

            // Clear any existing timeout
            if (window.loadingTimeoutId) {
                clearTimeout(window.loadingTimeoutId);
                window.loadingTimeoutId = null;
            }

            // Set a new timeout if loading is true
            if (isLoading) {
                console.log('Setting loading timeout...');
                window.loadingTimeoutId = setTimeout(() => {
                    // Force hide loading overlay after 15 seconds
                    if (state.loading) {
                        console.warn('Loading timeout reached. Forcing loading state to false.');
                        state.loading = false;
                        elements.loadingOverlay.style.display = 'none';
                        showNotification('Loading timed out. Please try again.', 'error');
                    }
                }, 15000); // 15 seconds timeout
            }
        }

        // Load initial cards with guaranteed completion
        async function loadInitialCards() {
            try {
                setLoading(true);
                const format = state.deck.format;

                // Try to get cards from api2.php first
                try {
                    const data = await apiRequest(`api2.php?action=get_high_synergy_cards&set_code=neo&min_stars=3&limit=20`);

                    if (data && data.cards && data.cards.length > 0) {
                        displayCards(data.cards);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to load cards from api2.php, trying api.php:', error);
                }

                // Fallback to api.php
                try {
                    const data = await apiRequest(`api.php?action=search&query=${format}&format=${format}&limit=20`);

                    if (data && data.cards && data.cards.length > 0) {
                        displayCards(data.cards);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to load cards from api.php:', error);
                }

                // If we get here, both APIs failed
                throw new Error('No cards returned from API');
            } catch (error) {
                console.error('Error loading cards:', error);
                showNotification('Failed to load cards. Using demo data.', 'error');
            } finally {
                // Ensure loading is set to false
                setLoading(false);
            }
        }

        // Load demo cards when API fails
        function loadDemoCards() {
            const demoCards = [
                {
                    id: 1,
                    name: "Chandra, Torch of Defiance",
                    type_line: "Legendary Planeswalker — Chandra",
                    mana_cost: "{2}{R}{R}",
                    cmc: 4,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 2,
                    name: "Goldspan Dragon",
                    type_line: "Creature — Dragon",
                    mana_cost: "{3}{R}{R}",
                    cmc: 5,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 3,
                    name: "Embercleave",
                    type_line: "Legendary Artifact — Equipment",
                    mana_cost: "{4}{R}{R}",
                    cmc: 6,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 4,
                    name: "Bonecrusher Giant",
                    type_line: "Creature — Giant",
                    mana_cost: "{1}{R}{R}",
                    cmc: 3,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 5,
                    name: "Torbran, Thane of Red Fell",
                    type_line: "Legendary Creature — Dwarf Noble",
                    mana_cost: "{1}{R}{R}{R}",
                    cmc: 4,
                    colors: ["R"],
                    color_identity: ["R"]
                }
            ];

            displayCards(demoCards);
        }

        // The rest of your functions remain the same

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            initializeForge();
            setupEventListeners();
            registerServiceWorker();
            loadInitialCards();
        });

        // Register service worker for offline functionality
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            }
        }

        // Enhanced API fetch function with timeout and better error handling
        async function apiRequest(endpoint, options = {}) {
            try {
                setLoading(true);

                // Default options
                const defaultOptions = {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    timeout: 10000 // 10 second timeout
                };

                // Merge options
                const fetchOptions = { ...defaultOptions, ...options };

                // Create an abort controller for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), fetchOptions.timeout);

                // Log request in debug mode
                if (state.debugMode) {
                    console.log(`API Request: ${endpoint}`, fetchOptions);
                }

                try {
                    // Make the request with timeout
                    const response = await fetch(endpoint, {
                        ...fetchOptions,
                        signal: controller.signal
                    });

                    // Clear timeout
                    clearTimeout(timeoutId);

                    // Check if response is ok
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    // Get response text first to check if it's valid JSON
                    const responseText = await response.text();

                    // Log raw response in debug mode
                    if (state.debugMode) {
                        console.log(`API Response (raw): ${responseText}`);
                    }

                    // Try to parse as JSON
                    let data;
                    try {
                        data = JSON.parse(responseText);
                    } catch (e) {
                        console.error('Invalid JSON response:', responseText);
                        throw new Error('Invalid JSON response from server');
                    }

                    // Check for API error
                    if (data && data.error) {
                        throw new Error(data.error);
                    }

                    return data;
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Request timed out');
                    }
                    throw error;
                }
            } catch (error) {
                console.error('API Request Error:', error);
                throw error;
            } finally {
                // Always ensure loading is set to false
                setLoading(false);
            }
        }

        // Load synergies for a card
        async function loadCardSynergies(cardId) {
            try {
                // Try api2.php first for enhanced synergy calculations
                try {
                    const data = await apiRequest(`${state.apiBaseUrl}api2.php?action=get_synergistic_cards&card_id=${cardId}`);

                    if (data && data.synergistic_cards && data.synergistic_cards.length > 0) {
                        // Format the synergies for display
                        const formattedSynergies = data.synergistic_cards.map(item => ({
                            synergy_card_id: item.card.id,
                            synergy_card_name: item.card.name,
                            synergy_card_type: item.card.type_line,
                            synergy_score: item.synergy_score,
                            combo_type: item.synergy_type
                        }));

                        displaySynergies(formattedSynergies);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to load synergies from api2.php, trying api.php:', error);
                }

                // Fallback to api.php
                const fallbackData = await apiRequest(`${state.apiBaseUrl}api.php?action=card&id=${cardId}`);

                if (fallbackData && fallbackData.synergies && fallbackData.synergies.length > 0) {
                    displaySynergies(fallbackData.synergies);
                } else {
                    throw new Error('No synergies found for this card');
                }
            } catch (error) {
                console.error('Error loading synergies:', error);
                showNotification('Failed to load synergies. Using demo data.', 'error');
                loadDemoSynergies(cardId);
            }
        }

        // Build a deck automatically based on the centerpiece
        async function buildDeck() {
            if (!state.selectedCard) {
                showNotification('Please select a centerpiece card first', 'error');
                return;
            }

            try {
                // Clear current deck
                state.deck.cards = {};

                // Use the advanced deck builder API
                try {
                    const data = await apiRequest(`${state.apiBaseUrl}api2.php?action=build_deck&card_id=${state.selectedCard.id}&deck_size=${state.deck.format === 'commander' ? 100 : 60}`);

                    if (data && !data.error) {
                        // Process non-land cards
                        if (data.non_land_cards && data.non_land_cards.length > 0) {
                            data.non_land_cards.forEach(card => {
                                state.deck.cards[card.id] = {
                                    id: card.id,
                                    name: card.name,
                                    type_line: card.type_line,
                                    cmc: card.cmc,
                                    mana_cost: card.mana_cost,
                                    colors: card.colors || [],
                                    color_identity: card.color_identity || [],
                                    quantity: 1
                                };
                            });
                        }

                        // Process lands
                        if (data.lands && data.lands.length > 0) {
                            data.lands.forEach((land, index) => {
                                const landId = `land_${Date.now()}_${index}`;
                                state.deck.cards[landId] = {
                                    id: landId,
                                    name: land.name,
                                    type_line: land.type_line || 'Basic Land',
                                    cmc: 0,
                                    mana_cost: '',
                                    colors: land.colors || [],
                                    color_identity: land.color_identity || [],
                                    quantity: 1
                                };
                            });
                        }

                        updateDeckDisplay();
                        showNotification('Deck built successfully!', 'success');
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to build deck with api2.php:', error);
                }

                // If we get here, api2.php failed or returned an error
                throw new Error('Could not build deck with API');
            } catch (error) {
                console.error('Error building deck:', error);
                showNotification('Failed to build deck. Using demo deck.', 'error');
                buildDemoDeck();
            }
        }

        // Analyze the current deck
        async function analyzeDeck() {
            if (Object.keys(state.deck.cards).length === 0) {
                showNotification('Please add cards to your deck first', 'error');
                return;
            }

            try {
                // Prepare deck list
                const deckList = [];

                // Add commander if exists
                if (state.deck.commander) {
                    deckList.push(state.deck.commander.name);
                }

                // Add all cards with quantities
                Object.values(state.deck.cards).forEach(card => {
                    for (let i = 0; i < card.quantity; i++) {
                        deckList.push(card.name);
                    }
                });

                // Try to analyze with API
                try {
                    const data = await apiRequest(`${state.apiBaseUrl}api.php?action=analyze_deck`, {
                        method: 'POST',
                        body: JSON.stringify({ deck: deckList })
                    });

                    if (data && !data.error) {
                        // Update synergy score
                        if (data.average_synergy) {
                            elements.synergyScore.textContent = Math.round(data.average_synergy * 100);
                        }

                        // Display analysis results
                        displayDeckAnalysis(data);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to analyze deck with API:', error);
                }

                // If we get here, API failed
                throw new Error('Could not analyze deck with API');
            } catch (error) {
                console.error('Error analyzing deck:', error);
                showNotification('Failed to analyze deck. Using demo analysis.', 'error');
                displayDemoAnalysis();
            }
        }

        // Load initial cards with guaranteed completion
        async function loadInitialCards() {
            try {
                setLoading(true);
                const format = state.deck.format;

                // Try to get cards from api2.php first
                try {
                    const data = await apiRequest(`api2.php?action=get_high_synergy_cards&set_code=neo&min_stars=3&limit=20`);

                    if (data && data.cards && data.cards.length > 0) {
                        displayCards(data.cards);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to load cards from api2.php, trying api.php:', error);
                }

                // Fallback to api.php
                try {
                    const data = await apiRequest(`api.php?action=search&query=${format}&format=${format}&limit=20`);

                    if (data && data.cards && data.cards.length > 0) {
                        displayCards(data.cards);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to load cards from api.php:', error);
                }

                // If we get here, both APIs failed
                throw new Error('No cards returned from API');
            } catch (error) {
                console.error('Error loading cards:', error);
                showNotification('Failed to load cards. Using demo data.', 'error');
                loadDemoCards();
            } finally {
                // Ensure loading is set to false
                setLoading(false);
            }
        }

        // Handle search
        async function handleSearch() {
            try {
                const searchQuery = document.getElementById('card-search').value;
                const format = state.deck.format;

                if (!searchQuery) {
                    loadInitialCards();
                    return;
                }

                // Try api2.php first
                try {
                    const data = await apiRequest(`${state.apiBaseUrl}api2.php?action=get_set_cards&set_code=${encodeURIComponent(searchQuery)}&limit=20`);

                    if (data && data.cards && data.cards.length > 0) {
                        displayCards(data.cards);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to search cards with api2.php, trying api.php:', error);
                }

                // Fallback to api.php
                const data = await apiRequest(`${state.apiBaseUrl}api.php?action=search&query=${encodeURIComponent(searchQuery)}&format=${format}&limit=20`);

                if (data && data.cards && data.cards.length > 0) {
                    displayCards(data.cards);
                } else {
                    throw new Error('No cards found matching your search');
                }
            } catch (error) {
                console.error('Error searching cards:', error);
                showNotification('Search failed: ' + error.message, 'error');

                // Try to search in demo cards
                const demoResults = searchDemoCards(document.getElementById('card-search').value);
                if (demoResults.length > 0) {
                    displayCards(demoResults);
                    showNotification('Showing demo results', 'info');
                } else {
                    elements.cardGrid.innerHTML = '<p>No cards found matching your criteria.</p>';
                }
            }
        }

        // The rest of your functions (initializeForge, setupEventListeners, etc.) remain the same

        // Create animated sparks
        function createSparks(container, count) {
            for (let i = 0; i < count; i++) {
                const spark = document.createElement('div');
                spark.className = 'spark';

                // Random position
                const left = Math.random() * 100;
                spark.style.left = `${left}%`;
                spark.style.bottom = '40%';

                // Random x offset for animation
                const xOffset = -50 + Math.random() * 100;
                spark.style.setProperty('--x-offset', `${xOffset}px`);

                // Random delay
                const delay = Math.random() * 2;
                spark.style.animationDelay = `${delay}s`;

                container.appendChild(spark);
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // Search button
            document.getElementById('search-btn').addEventListener('click', handleSearch);

            // Enter key in search input
            document.getElementById('card-search').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleSearch();
            });

            // Format buttons
            document.querySelectorAll('.format-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.deck.format = btn.dataset.format;
                    loadInitialCards();
                });
            });

            // Deck tabs
            document.querySelectorAll('.deck-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.deck-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    state.currentTab = tab.dataset.tab;
                    updateDeckDisplay();
                });
            });

            // Deck actions
            document.getElementById('build-deck-btn').addEventListener('click', buildDeck);
            document.getElementById('analyze-deck-btn').addEventListener('click', analyzeDeck);
            document.getElementById('save-deck-btn').addEventListener('click', saveDeck);
            document.getElementById('clear-deck-btn').addEventListener('click', clearDeck);

            // Deck name input
            document.getElementById('deck-name').addEventListener('input', (e) => {
                state.deck.name = e.target.value;
            });

            // Forge click to create spark burst
            document.querySelector('.forge').addEventListener('click', (e) => {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                createSparkBurst(elements.forgeSparks, x, y);
            });
        }

        // Create a burst of sparks at a specific position
        function createSparkBurst(container, x, y) {
            const burstCount = 15;

            for (let i = 0; i < burstCount; i++) {
                const spark = document.createElement('div');
                spark.className = 'spark';

                // Position at click point
                spark.style.left = `${x}px`;
                spark.style.top = `${y}px`;

                // Random movement direction
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                const xOffset = Math.cos(angle) * distance;
                const yOffset = Math.sin(angle) * distance;

                // Custom animation for burst sparks
                spark.style.animation = 'none';
                spark.style.opacity = '1';
                spark.style.transition = 'all 1s ease-out';

                // Trigger animation
                setTimeout(() => {
                    spark.style.transform = `translate(${xOffset}px, ${yOffset}px)`;
                    spark.style.opacity = '0';
                }, 10);

                container.appendChild(spark);

                // Remove spark after animation
                setTimeout(() => {
                    if (container.contains(spark)) {
                        container.removeChild(spark);
                    }
                }, 1000);
            }
        }

        // Enhanced API fetch function with better error handling
        async function apiRequest(endpoint, options = {}) {
            try {
                setLoading(true);

                // Default options
                const defaultOptions = {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                };

                // Merge options
                const fetchOptions = { ...defaultOptions, ...options };

                // Log request in debug mode
                if (state.debugMode) {
                    console.log(`API Request: ${endpoint}`, fetchOptions);
                }

                // Make the request
                const response = await fetch(endpoint, fetchOptions);

                // Check if response is ok
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                // Get response text first to check if it's valid JSON
                const responseText = await response.text();

                // Log raw response in debug mode
                if (state.debugMode) {
                    console.log(`API Response (raw): ${responseText}`);
                }

                // Try to parse as JSON
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (e) {
                    console.error('Invalid JSON response:', responseText);
                    throw new Error('Invalid JSON response from server');
                }

                // Log parsed data in debug mode
                if (state.debugMode) {
                    console.log('API Response (parsed):', data);
                }

                // Check for API error
                if (data.error) {
                    throw new Error(data.error);
                }

                return data;
            } catch (error) {
                console.error('API Request Error:', error);
                throw error;
            } finally {
                setLoading(false);
            }
        }

        // Load initial cards
        async function loadInitialCards() {
            try {
                const format = state.deck.format;

                // Try to get cards from api2.php first
                try {
                    const data = await apiRequest(`api2.php?action=get_high_synergy_cards&set_code=neo&min_stars=3&limit=20`);

                    if (data && data.cards && data.cards.length > 0) {
                        displayCards(data.cards);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to load cards from api2.php, trying api.php:', error);
                }

                // Fallback to api.php
                const data = await apiRequest(`api.php?action=search&query=${format}&format=${format}&limit=20`);

                if (data && data.cards && data.cards.length > 0) {
                    displayCards(data.cards);
                } else {
                    throw new Error('No cards returned from API');
                }
            } catch (error) {
                console.error('Error loading cards:', error);
                showNotification('Failed to load cards. Using demo data.', 'error');
                loadDemoCards();
            }
        }

        // Load demo cards when API fails
        function loadDemoCards() {
            const demoCards = [
                {
                    id: 1,
                    name: "Chandra, Torch of Defiance",
                    type_line: "Legendary Planeswalker — Chandra",
                    mana_cost: "{2}{R}{R}",
                    cmc: 4,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 2,
                    name: "Goldspan Dragon",
                    type_line: "Creature — Dragon",
                    mana_cost: "{3}{R}{R}",
                    cmc: 5,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 3,
                    name: "Embercleave",
                    type_line: "Legendary Artifact — Equipment",
                    mana_cost: "{4}{R}{R}",
                    cmc: 6,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 4,
                    name: "Bonecrusher Giant",
                    type_line: "Creature — Giant",
                    mana_cost: "{1}{R}{R}",
                    cmc: 3,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 5,
                    name: "Torbran, Thane of Red Fell",
                    type_line: "Legendary Creature — Dwarf Noble",
                    mana_cost: "{1}{R}{R}{R}",
                    cmc: 4,
                    colors: ["R"],
                    color_identity: ["R"]
                }
            ];

            displayCards(demoCards);
        }

        // Handle search
        async function handleSearch() {
            try {
                const searchQuery = document.getElementById('card-search').value;
                const format = state.deck.format;

                if (!searchQuery) {
                    loadInitialCards();
                    return;
                }

                // Try api2.php first
                try {
                    const data = await apiRequest(`api2.php?action=get_set_cards&set_code=${encodeURIComponent(searchQuery)}&limit=20`);

                    if (data && data.cards && data.cards.length > 0) {
                        displayCards(data.cards);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to search cards with api2.php, trying api.php:', error);
                }

                // Fallback to api.php
                const data = await apiRequest(`api.php?action=search&query=${encodeURIComponent(searchQuery)}&format=${format}&limit=20`);

                if (data && data.cards && data.cards.length > 0) {
                    displayCards(data.cards);
                } else {
                    throw new Error('No cards found matching your search');
                }
            } catch (error) {
                console.error('Error searching cards:', error);
                showNotification('Search failed: ' + error.message, 'error');

                // Try to search in demo cards
                const demoResults = searchDemoCards(document.getElementById('card-search').value);
                if (demoResults.length > 0) {
                    displayCards(demoResults);
                    showNotification('Showing demo results', 'info');
                } else {
                    elements.cardGrid.innerHTML = '<p>No cards found matching your criteria.</p>';
                }
            }
        }

        // Search in demo cards
        function searchDemoCards(query) {
            query = query.toLowerCase();

            const demoCards = [
                {
                    id: 1,
                    name: "Chandra, Torch of Defiance",
                    type_line: "Legendary Planeswalker — Chandra",
                    mana_cost: "{2}{R}{R}",
                    cmc: 4,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 2,
                    name: "Goldspan Dragon",
                    type_line: "Creature — Dragon",
                    mana_cost: "{3}{R}{R}",
                    cmc: 5,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 3,
                    name: "Embercleave",
                    type_line: "Legendary Artifact — Equipment",
                    mana_cost: "{4}{R}{R}",
                    cmc: 6,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 4,
                    name: "Bonecrusher Giant",
                    type_line: "Creature — Giant",
                    mana_cost: "{1}{R}{R}",
                    cmc: 3,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 5,
                    name: "Torbran, Thane of Red Fell",
                    type_line: "Legendary Creature — Dwarf Noble",
                    mana_cost: "{1}{R}{R}{R}",
                    cmc: 4,
                    colors: ["R"],
                    color_identity: ["R"]
                },
                {
                    id: 6,
                    name: "Llanowar Elves",
                    type_line: "Creature — Elf Druid",
                    mana_cost: "{G}",
                    cmc: 1,
                    colors: ["G"],
                    color_identity: ["G"]
                },
                {
                    id: 7,
                    name: "Counterspell",
                    type_line: "Instant",
                    mana_cost: "{U}{U}",
                    cmc: 2,
                    colors: ["U"],
                    color_identity: ["U"]
                },
                {
                    id: 8,
                    name: "Thoughtseize",
                    type_line: "Sorcery",
                    mana_cost: "{B}",
                    cmc: 1,
                    colors: ["B"],
                    color_identity: ["B"]
                },
                {
                    id: 9,
                    name: "Wrath of God",
                    type_line: "Sorcery",
                    mana_cost: "{2}{W}{W}",
                    cmc: 4,
                    colors: ["W"],
                    color_identity: ["W"]
                },
                {
                    id: 10,
                    name: "Lightning Bolt",
                    type_line: "Instant",
                    mana_cost: "{R}",
                    cmc: 1,
                    colors: ["R"],
                    color_identity: ["R"]
                }
            ];

            return demoCards.filter(card =>
                card.name.toLowerCase().includes(query) ||
                card.type_line.toLowerCase().includes(query)
            );
        }

        // Display cards in the card grid
        function displayCards(cards) {
            elements.cardGrid.innerHTML = '';

            if (!cards || cards.length === 0) {
                elements.cardGrid.innerHTML = '<p>No cards found matching your criteria.</p>';
                return;
            }

            cards.forEach(card => {
                const cardElement = createCardElement(card);
                elements.cardGrid.appendChild(cardElement);
            });
        }

        // Create a card element
        function createCardElement(card) {
            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container';

            const cardElement = document.createElement('div');
            cardElement.className = 'card';
            cardElement.dataset.cardId = card.id;

            // Card image
            const cardImage = document.createElement('img');
            cardImage.className = 'card-image';
            cardImage.src = card.image_uri || `https://api.scryfall.com/cards/named?format=image&exact=${encodeURIComponent(card.name)}`;
            cardImage.alt = card.name;
            cardImage.loading = 'lazy';

            // Handle image loading error
            cardImage.onerror = function () {
                this.src = 'https://c1.scryfall.com/file/scryfall-card-backs/large/59/597b79b3-7d77-4261-871a-60dd17403388.jpg';
            };

            // Card overlay
            const cardOverlay = document.createElement('div');
            cardOverlay.className = 'card-overlay';

            // Card name
            const cardName = document.createElement('div');
            cardName.className = 'card-name';
            cardName.textContent = card.name;

            // Card type
            const cardType = document.createElement('div');
            cardType.className = 'card-type';
            cardType.textContent = card.type_line || 'Unknown Type';

            // Card actions
            const cardActions = document.createElement('div');
            cardActions.className = 'card-actions';

            // Add to deck button
            const addButton = document.createElement('button');
            addButton.className = 'card-btn';
            addButton.textContent = 'Add to Deck';
            addButton.addEventListener('click', (e) => {
                e.stopPropagation();
                addCardToDeck(card);
            });

            // View synergies button
            const synergiesButton = document.createElement('button');
            synergiesButton.className = 'card-btn';
            synergiesButton.textContent = 'Synergies';
            synergiesButton.addEventListener('click', (e) => {
                e.stopPropagation();
                selectCenterpiece(card);
            });

            // Assemble card
            cardActions.appendChild(addButton);
            cardActions.appendChild(synergiesButton);

            cardOverlay.appendChild(cardName);
            cardOverlay.appendChild(cardType);
            cardOverlay.appendChild(cardActions);

            cardElement.appendChild(cardImage);
            cardElement.appendChild(cardOverlay);

            // Add click event to select card
            cardElement.addEventListener('click', () => {
                selectCenterpiece(card);
            });

            cardContainer.appendChild(cardElement);
            return cardContainer;
        }

        // Select a centerpiece card
        function selectCenterpiece(card) {
            state.selectedCard = card;

            // Update forge title
            elements.forgeTitle.textContent = `Centerpiece: ${card.name}`;

            // Create spark burst effect
            const forge = document.querySelector('.forge');
            const rect = forge.getBoundingClientRect();
            createSparkBurst(elements.forgeSparks, rect.width / 2, rect.height / 2);

            // Load synergies for this card
            loadCardSynergies(card.id);

            // If commander format and card is legendary creature, set as commander
            if (state.deck.format === 'commander' &&
                card.type_line &&
                card.type_line.includes('Legendary') &&
                card.type_line.includes('Creature')) {
                state.deck.commander = card;
                showNotification(`${card.name} set as your commander!`, 'success');
                updateDeckDisplay();
            }
        }

        // Load synergies for a card
        async function loadCardSynergies(cardId) {
            try {
                // Try api2.php first
                try {
                    const data = await apiRequest(`api2.php?action=get_synergistic_cards&card_id=${cardId}`);

                    if (data && data.synergistic_cards && data.synergistic_cards.length > 0) {
                        // Format the synergies for display
                        const formattedSynergies = data.synergistic_cards.map(item => ({
                            synergy_card_id: item.card.id,
                            synergy_card_name: item.card.name,
                            synergy_card_type: item.card.type_line,
                            synergy_score: item.synergy_score,
                            combo_type: item.synergy_type
                        }));

                        displaySynergies(formattedSynergies);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to load synergies from api2.php, trying api.php:', error);
                }

                // Fallback to api.php
                const data = await apiRequest(`api.php?action=card&id=${cardId}`);

                if (data && data.synergies && data.synergies.length > 0) {
                    displaySynergies(data.synergies);
                } else {
                    throw new Error('No synergies found for this card');
                }
            } catch (error) {
                console.error('Error loading synergies:', error);
                showNotification('Failed to load synergies. Using demo data.', 'error');
                loadDemoSynergies(cardId);
            }
        }

        // Load demo synergies when API fails
        function loadDemoSynergies(cardId) {
            const demoSynergies = [
                {
                    synergy_card_id: 101,
                    synergy_card_name: "Lightning Bolt",
                    synergy_card_type: "Instant",
                    synergy_score: 0.85,
                    combo_type: "aggro"
                },
                {
                    synergy_card_id: 102,
                    synergy_card_name: "Shock",
                    synergy_card_type: "Instant",
                    synergy_score: 0.75,
                    combo_type: "aggro"
                },
                {
                    synergy_card_id: 103,
                    synergy_card_name: "Goblin Guide",
                    synergy_card_type: "Creature — Goblin Scout",
                    synergy_score: 0.65,
                    combo_type: "aggro"
                },
                {
                    synergy_card_id: 104,
                    synergy_card_name: "Monastery Swiftspear",
                    synergy_card_type: "Creature — Human Monk",
                    synergy_score: 0.60,
                    combo_type: "aggro"
                },
                {
                    synergy_card_id: 105,
                    synergy_card_name: "Light Up the Stage",
                    synergy_card_type: "Sorcery",
                    synergy_score: 0.55,
                    combo_type: "card_advantage"
                }
            ];

            displaySynergies(demoSynergies);
        }

        // Display synergies in the synergy grid
        function displaySynergies(synergies) {
            elements.synergyGrid.innerHTML = '';

            if (!synergies || synergies.length === 0) {
                elements.synergyGrid.innerHTML = '<p>No synergies found for this card.</p>';
                return;
            }

            synergies.forEach(synergy => {
                const synergyElement = createSynergyElement(synergy);
                elements.synergyGrid.appendChild(synergyElement);
            });
        }

        // Create a synergy card element
        function createSynergyElement(synergy) {
            const synergyCard = document.createElement('div');
            synergyCard.className = 'synergy-card';

            // Synergy type badge
            if (synergy.combo_type && synergy.combo_type !== 'general_synergy' && synergy.combo_type !== 'general') {
                const synergyType = document.createElement('div');
                synergyType.className = 'synergy-type';
                synergyType.textContent = synergy.combo_type.replace(/_/g, ' ');
                synergyCard.appendChild(synergyType);
            }

            // Card image
            const cardImage = document.createElement('img');
            cardImage.className = 'synergy-card-image';
            cardImage.src = `https://api.scryfall.com/cards/named?format=image&exact=${encodeURIComponent(synergy.synergy_card_name)}`;
            cardImage.alt = synergy.synergy_card_name;
            cardImage.loading = 'lazy';

            // Handle image loading error
            cardImage.onerror = function () {
                this.src = 'https://c1.scryfall.com/file/scryfall-card-backs/large/59/597b79b3-7d77-4261-871a-60dd17403388.jpg';
            };

            // Card info
            const cardInfo = document.createElement('div');
            cardInfo.className = 'synergy-card-info';

            // Card name
            const cardName = document.createElement('div');
            cardName.className = 'synergy-card-name';
            cardName.textContent = synergy.synergy_card_name;

            // Synergy score
            const synergyScore = document.createElement('div');
            synergyScore.className = 'synergy-score';

            // Stars based on synergy score
            const stars = document.createElement('div');
            stars.className = 'synergy-stars';
            const starCount = Math.min(5, Math.max(1, Math.ceil(synergy.synergy_score * 5)));
            stars.textContent = '★'.repeat(starCount);

            // Percentage
            const percentage = document.createElement('div');
            percentage.className = 'synergy-percentage';
            percentage.textContent = `${Math.round(synergy.synergy_score * 100)}%`;

            synergyScore.appendChild(stars);
            synergyScore.appendChild(percentage);

            cardInfo.appendChild(cardName);
            cardInfo.appendChild(synergyScore);

            // Add to deck button
            const addButton = document.createElement('button');
            addButton.className = 'add-synergy-btn';
            addButton.textContent = 'Add to Deck';
            addButton.addEventListener('click', () => {
                // Create a card object from the synergy data
                const card = {
                    id: synergy.synergy_card_id,
                    name: synergy.synergy_card_name,
                    type_line: synergy.synergy_card_type || '',
                    cmc: 0, // We don't have CMC in the synergy data
                    colors: [],
                    color_identity: []
                };

                addCardToDeck(card);
                showNotification(`Added ${card.name} to deck`, 'success');
            });

            // Assemble synergy card
            synergyCard.appendChild(cardImage);
            synergyCard.appendChild(cardInfo);
            synergyCard.appendChild(addButton);

            return synergyCard;
        }

        // Build a deck automatically based on the centerpiece
        async function buildDeck() {
            if (!state.selectedCard) {
                showNotification('Please select a centerpiece card first', 'error');
                return;
            }

            try {
                // Clear current deck
                state.deck.cards = {};

                // Try api2.php first
                try {
                    const data = await apiRequest(`api2.php?action=build_deck&card_id=${state.selectedCard.id}&deck_size=${state.deck.format === 'commander' ? 100 : 60}`);

                    if (data && !data.error) {
                        // Add non-land cards to deck
                        if (data.non_land_cards && data.non_land_cards.length > 0) {
                            data.non_land_cards.forEach(card => {
                                state.deck.cards[card.id] = {
                                    id: card.id,
                                    name: card.name,
                                    type_line: card.type_line,
                                    cmc: card.cmc,
                                    mana_cost: card.mana_cost,
                                    colors: card.colors || [],
                                    color_identity: card.color_identity || [],
                                    quantity: 1
                                };
                            });
                        }

                        // Add lands to deck
                        if (data.lands && data.lands.length > 0) {
                            data.lands.forEach((land, index) => {
                                const landId = `land_${Date.now()}_${index}`;
                                state.deck.cards[landId] = {
                                    id: landId,
                                    name: land.name,
                                    type_line: land.type_line || 'Basic Land',
                                    cmc: 0,
                                    mana_cost: '',
                                    colors: land.colors || [],
                                    color_identity: land.color_identity || [],
                                    quantity: 1
                                };
                            });
                        }

                        updateDeckDisplay();
                        showNotification('Deck built successfully!', 'success');
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to build deck with api2.php:', error);
                }

                // If we get here, api2.php failed or returned an error
                throw new Error('Could not build deck with API');
            } catch (error) {
                console.error('Error building deck:', error);
                showNotification('Failed to build deck. Using demo deck.', 'error');
                buildDemoDeck();
            }
        }

        // Build a demo deck when API fails
        function buildDemoDeck() {
            // Clear current deck
            state.deck.cards = {};

            // Get centerpiece card colors
            const centerpiece = state.selectedCard;
            const colors = centerpiece.colors || centerpiece.color_identity || [];

            // Add centerpiece card to deck
            state.deck.cards[centerpiece.id] = {
                ...centerpiece,
                quantity: 1
            };

            // Define demo cards by color
            const demoCardsByColor = {
                'W': [
                    { name: "Plains", type_line: "Basic Land — Plains", cmc: 0, colors: [], color_identity: ['W'] },
                    { name: "Swords to Plowshares", type_line: "Instant", cmc: 1, colors: ['W'], color_identity: ['W'] },
                    { name: "Path to Exile", type_line: "Instant", cmc: 1, colors: ['W'], color_identity: ['W'] },
                    { name: "Wrath of God", type_line: "Sorcery", cmc: 4, colors: ['W'], color_identity: ['W'] },
                    { name: "Elspeth, Sun's Champion", type_line: "Legendary Planeswalker — Elspeth", cmc: 6, colors: ['W'], color_identity: ['W'] }
                ],
                'U': [
                    { name: "Island", type_line: "Basic Land — Island", cmc: 0, colors: [], color_identity: ['U'] },
                    { name: "Counterspell", type_line: "Instant", cmc: 2, colors: ['U'], color_identity: ['U'] },
                    { name: "Brainstorm", type_line: "Instant", cmc: 1, colors: ['U'], color_identity: ['U'] },
                    { name: "Cryptic Command", type_line: "Instant", cmc: 4, colors: ['U'], color_identity: ['U'] },
                    { name: "Jace, the Mind Sculptor", type_line: "Legendary Planeswalker — Jace", cmc: 4, colors: ['U'], color_identity: ['U'] }
                ],
                'B': [
                    { name: "Swamp", type_line: "Basic Land — Swamp", cmc: 0, colors: [], color_identity: ['B'] },
                    { name: "Thoughtseize", type_line: "Sorcery", cmc: 1, colors: ['B'], color_identity: ['B'] },
                    { name: "Fatal Push", type_line: "Instant", cmc: 1, colors: ['B'], color_identity: ['B'] },
                    { name: "Doom Blade", type_line: "Instant", cmc: 2, colors: ['B'], color_identity: ['B'] },
                    { name: "Liliana of the Veil", type_line: "Legendary Planeswalker — Liliana", cmc: 3, colors: ['B'], color_identity: ['B'] }
                ],
                'R': [
                    { name: "Mountain", type_line: "Basic Land — Mountain", cmc: 0, colors: [], color_identity: ['R'] },
                    { name: "Lightning Bolt", type_line: "Instant", cmc: 1, colors: ['R'], color_identity: ['R'] },
                    { name: "Goblin Guide", type_line: "Creature — Goblin Scout", cmc: 1, colors: ['R'], color_identity: ['R'] },
                    { name: "Faithless Looting", type_line: "Sorcery", cmc: 1, colors: ['R'], color_identity: ['R'] },
                    { name: "Chandra, Torch of Defiance", type_line: "Legendary Planeswalker — Chandra", cmc: 4, colors: ['R'], color_identity: ['R'] }
                ],
                'G': [
                    { name: "Forest", type_line: "Basic Land — Forest", cmc: 0, colors: [], color_identity: ['G'] },
                    { name: "Llanowar Elves", type_line: "Creature — Elf Druid", cmc: 1, colors: ['G'], color_identity: ['G'] },
                    { name: "Tarmogoyf", type_line: "Creature — Lhurgoyf", cmc: 2, colors: ['G'], color_identity: ['G'] },
                    { name: "Cultivate", type_line: "Sorcery", cmc: 3, colors: ['G'], color_identity: ['G'] },
                    { name: "Nissa, Who Shakes the World", type_line: "Legendary Planeswalker — Nissa", cmc: 5, colors: ['G'], color_identity: ['G'] }
                ],
                'C': [
                    { name: "Wastes", type_line: "Basic Land — Wastes", cmc: 0, colors: [], color_identity: [] },
                    { name: "Sol Ring", type_line: "Artifact", cmc: 1, colors: [], color_identity: [] },
                    { name: "Mind Stone", type_line: "Artifact", cmc: 2, colors: [], color_identity: [] },
                    { name: "Hedron Archive", type_line: "Artifact", cmc: 4, colors: [], color_identity: [] },
                    { name: "Ugin, the Spirit Dragon", type_line: "Legendary Planeswalker — Ugin", cmc: 8, colors: [], color_identity: [] }
                ]
            };

            // Determine which colors to use
            let deckColors = colors.length > 0 ? colors : ['C'];

            // Add cards for each color
            deckColors.forEach(color => {
                const colorCards = demoCardsByColor[color] || demoCardsByColor['C'];

                // Add basic lands
                for (let i = 0; i < 8; i++) {
                    const landId = `land_${color}_${i}`;
                    state.deck.cards[landId] = {
                        id: landId,
                        name: colorCards[0].name,
                        type_line: colorCards[0].type_line,
                        cmc: 0,
                        colors: colorCards[0].colors,
                        color_identity: colorCards[0].color_identity,
                        quantity: 1
                    };
                }

                // Add spells
                for (let i = 1; i < colorCards.length; i++) {
                    const cardId = `card_${color}_${i}`;
                    state.deck.cards[cardId] = {
                        id: cardId,
                        name: colorCards[i].name,
                        type_line: colorCards[i].type_line,
                        cmc: colorCards[i].cmc,
                        colors: colorCards[i].colors,
                        color_identity: colorCards[i].color_identity,
                        quantity: 4
                    };
                }
            });

            // Add some generic artifacts
            const artifacts = [
                { name: "Sol Ring", type_line: "Artifact", cmc: 1 },
                { name: "Arcane Signet", type_line: "Artifact", cmc: 2 },
                { name: "Chromatic Lantern", type_line: "Artifact", cmc: 3 }
            ];

            artifacts.forEach((card, index) => {
                const cardId = `artifact_${index}`;
                state.deck.cards[cardId] = {
                    id: cardId,
                    name: card.name,
                    type_line: card.type_line,
                    cmc: card.cmc,
                    colors: [],
                    color_identity: [],
                    quantity: 1
                };
            });

            updateDeckDisplay();
            showNotification('Demo deck built based on centerpiece colors', 'info');
        }

        // Add a card to the deck
        function addCardToDeck(card) {
            // Check if card is already in deck
            if (state.deck.cards[card.id]) {
                // Increment quantity
                state.deck.cards[card.id].quantity++;
            } else {
                // Add new card
                state.deck.cards[card.id] = {
                    ...card,
                    quantity: 1
                };
            }

            updateDeckDisplay();
            showNotification(`Added ${card.name} to deck`, 'success');
        }

        // Remove a card from the deck
        function removeCardFromDeck(cardId) {
            if (state.deck.cards[cardId]) {
                if (state.deck.cards[cardId].quantity > 1) {
                    // Decrement quantity
                    state.deck.cards[cardId].quantity--;
                } else {
                    // Remove card
                    delete state.deck.cards[cardId];
                }

                updateDeckDisplay();
            }
        }

        // Update the deck display
        function updateDeckDisplay() {
            // Clear deck content
            elements.deckContent.innerHTML = '';

            // Get all cards in the deck
            const cards = Object.values(state.deck.cards);

            // Filter cards based on current tab
            let filteredCards = cards;
            if (state.currentTab === 'creatures') {
                filteredCards = cards.filter(card => card.type_line && card.type_line.toLowerCase().includes('creature'));
            } else if (state.currentTab === 'spells') {
                filteredCards = cards.filter(card => {
                    const type = card.type_line ? card.type_line.toLowerCase() : '';
                    return type.includes('instant') || type.includes('sorcery') ||
                        type.includes('enchantment') || type.includes('artifact') ||
                        type.includes('planeswalker');
                });
            } else if (state.currentTab === 'lands') {
                filteredCards = cards.filter(card => card.type_line && card.type_line.toLowerCase().includes('land'));
            }

            // Sort cards by name
            filteredCards.sort((a, b) => a.name.localeCompare(b.name));

            // Check if deck is empty
            if (cards.length === 0 && !state.deck.commander) {
                elements.emptyDeckMessage.style.display = 'block';
                elements.deckContent.appendChild(elements.emptyDeckMessage);
            } else {
                elements.emptyDeckMessage.style.display = 'none';

                // Add commander if exists
                if (state.deck.commander) {
                    const commanderSection = createDeckSection('Commander', [state.deck.commander]);
                    elements.deckContent.appendChild(commanderSection);
                }

                // Add filtered cards
                if (filteredCards.length > 0) {
                    const cardsSection = createDeckSection(state.currentTab.charAt(0).toUpperCase() + state.currentTab.slice(1), filteredCards);
                    elements.deckContent.appendChild(cardsSection);
                } else {
                    const emptyMessage = document.createElement('p');
                    emptyMessage.textContent = `No ${state.currentTab} in your deck.`;
                    elements.deckContent.appendChild(emptyMessage);
                }
            }

            // Update stats
            updateDeckStats();

            // Update mana curve
            updateManaCurve();

            // Update color distribution
            updateColorDistribution();
        }

        // Create a deck section
        function createDeckSection(title, cards) {
            const section = document.createElement('div');
            section.className = 'deck-section';

            const header = document.createElement('div');
            header.className = 'section-header';

            const sectionTitle = document.createElement('div');
            sectionTitle.className = 'section-title';
            sectionTitle.textContent = title;

            const sectionCount = document.createElement('div');
            sectionCount.className = 'section-count';
            const totalCount = cards.reduce((sum, card) => sum + (card.quantity || 1), 0);
            sectionCount.textContent = `${totalCount} cards`;

            header.appendChild(sectionTitle);
            header.appendChild(sectionCount);

            const deckCards = document.createElement('div');
            deckCards.className = 'deck-cards';

            cards.forEach(card => {
                const cardElement = createDeckCardElement(card);
                deckCards.appendChild(cardElement);
            });

            section.appendChild(header);
            section.appendChild(deckCards);

            return section;
        }

        // Create a deck card element
        function createDeckCardElement(card) {
            const cardElement = document.createElement('div');
            cardElement.className = 'deck-card';

            // Card quantity
            const quantity = document.createElement('div');
            quantity.className = 'card-quantity';
            quantity.textContent = card.quantity || 1;

            // Quantity controls
            const quantityControls = document.createElement('div');
            quantityControls.className = 'quantity-controls';

            const increaseBtn = document.createElement('button');
            increaseBtn.className = 'quantity-btn';
            increaseBtn.textContent = '▲';
            increaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                addCardToDeck(card);
            });

            const decreaseBtn = document.createElement('button');
            decreaseBtn.className = 'quantity-btn';
            decreaseBtn.textContent = '▼';
            decreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeCardFromDeck(card.id);
            });

            quantityControls.appendChild(increaseBtn);
            quantityControls.appendChild(decreaseBtn);

            // Card info
            const cardInfo = document.createElement('div');
            cardInfo.className = 'card-info';

            const cardName = document.createElement('div');
            cardName.className = 'card-name';
            cardName.textContent = card.name;

            const cardType = document.createElement('div');
            cardType.className = 'card-type';
            cardType.textContent = card.type_line || '';

            cardInfo.appendChild(cardName);
            cardInfo.appendChild(cardType);

            // Card mana cost
            const cardCost = document.createElement('div');
            cardCost.className = 'card-cost';
            cardCost.textContent = card.cmc || '0';

            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-card';
            removeBtn.textContent = '×';
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();

                // If it's the commander
                if (state.deck.commander && state.deck.commander.id === card.id) {
                    state.deck.commander = null;
                    showNotification(`Removed ${card.name} as commander`, 'info');
                } else {
                    // Remove all copies
                    delete state.deck.cards[card.id];
                    showNotification(`Removed ${card.name} from deck`, 'info');
                }

                updateDeckDisplay();
            });

            // Assemble card element
            cardElement.appendChild(quantity);
            cardElement.appendChild(quantityControls);
            cardElement.appendChild(cardInfo);
            cardElement.appendChild(cardCost);
            cardElement.appendChild(removeBtn);

            return cardElement;
        }

        // Update deck statistics
        function updateDeckStats() {
            // Count cards
            let totalCards = Object.values(state.deck.cards).reduce((sum, card) => sum + card.quantity, 0);
            if (state.deck.commander) totalCards++;

            // Calculate average CMC
            let totalCmc = Object.values(state.deck.cards).reduce((sum, card) => {
                return sum + (card.cmc || 0) * card.quantity;
            }, 0);

            if (state.deck.commander) {
                totalCmc += (state.deck.commander.cmc || 0);
            }

            const avgCmc = totalCards > 0 ? totalCmc / totalCards : 0;

            // Update display
            elements.cardCount.textContent = totalCards;
            elements.avgCmc.textContent = avgCmc.toFixed(1);

            // Calculate synergy score if we have a centerpiece
            if (state.selectedCard && Object.keys(state.deck.cards).length > 0) {
                // For now, use a placeholder value
                elements.synergyScore.textContent = '...';

                // Calculate synergy score asynchronously
                setTimeout(() => {
                    const synergyScore = calculateEstimatedSynergyScore();
                    elements.synergyScore.textContent = synergyScore;
                }, 100);
            } else {
                elements.synergyScore.textContent = '0';
            }
        }

        // Calculate estimated synergy score
        function calculateEstimatedSynergyScore() {
            // This is a simplified version that doesn't make API calls
            // In a real implementation, you would calculate this based on
            // the synergies between the centerpiece and other cards

            // Get number of cards in the deck
            const cardCount = Object.values(state.deck.cards).reduce((sum, card) => sum + card.quantity, 0);

            if (cardCount === 0) return '0';

            // Generate a score based on the number of cards
            // This is just for demonstration purposes
            const baseScore = 50 + Math.min(30, cardCount * 2);

            // Add some randomness to make it look realistic
            const randomFactor = Math.floor(Math.random() * 20) - 10;

            return Math.min(99, Math.max(1, baseScore + randomFactor)).toString();
        }

        // Update mana curve display
        function updateManaCurve() {
            elements.manaCurve.innerHTML = '';

            // Count cards by CMC
            const cmcCounts = {};

            // Add commander if exists
            if (state.deck.commander) {
                const cmc = Math.min(7, Math.max(0, Math.floor(state.deck.commander.cmc || 0)));
                cmcCounts[cmc] = (cmcCounts[cmc] || 0) + 1;
            }

            // Add all cards
            Object.values(state.deck.cards).forEach(card => {
                const cmc = Math.min(7, Math.max(0, Math.floor(card.cmc || 0)));
                cmcCounts[cmc] = (cmcCounts[cmc] || 0) + card.quantity;
            });

            // Create bars for CMC 0-7+
            for (let i = 0; i <= 7; i++) {
                const count = cmcCounts[i] || 0;

                const bar = document.createElement('div');
                bar.className = 'curve-bar';

                // Set height based on count (max height for the highest count)
                const maxCount = Math.max(...Object.values(cmcCounts), 1);
                const height = count > 0 ? (count / maxCount) * 100 : 0;
                bar.style.height = `${height}%`;

                // Add count label
                if (count > 0) {
                    const countLabel = document.createElement('div');
                    countLabel.className = 'curve-bar-count';
                    countLabel.textContent = count;
                    bar.appendChild(countLabel);
                }

                // Add CMC label
                const label = document.createElement('div');
                label.className = 'curve-bar-label';
                label.textContent = i === 7 ? '7+' : i;
                bar.appendChild(label);

                elements.manaCurve.appendChild(bar);
            }
        }

        // Update color distribution display
        function updateColorDistribution() {
            elements.colorPips.innerHTML = '';

            // Count color pips
            const colorCounts = {
                'W': 0,
                'U': 0,
                'B': 0,
                'R': 0,
                'G': 0,
                'C': 0
            };

            // Add commander if exists
            if (state.deck.commander) {
                const colors = Array.isArray(state.deck.commander.color_identity)
                    ? state.deck.commander.color_identity
                    : (state.deck.commander.colors || []);

                colors.forEach(color => {
                    colorCounts[color] = (colorCounts[color] || 0) + 1;
                });

                // If colorless
                if (colors.length === 0) {
                    colorCounts['C'] = (colorCounts['C'] || 0) + 1;
                }
            }

            // Add all cards
            Object.values(state.deck.cards).forEach(card => {
                const colors = Array.isArray(card.color_identity)
                    ? card.color_identity
                    : (card.colors || []);

                colors.forEach(color => {
                    colorCounts[color] = (colorCounts[color] || 0) + card.quantity;
                });

                // If colorless
                if (colors.length === 0) {
                    colorCounts['C'] = (colorCounts['C'] || 0) + card.quantity;
                }
            });

            // Create color pips
            Object.entries(colorCounts).forEach(([color, count]) => {
                if (count > 0) {
                    const pip = document.createElement('div');
                    pip.className = `color-pip color-${color}`;
                    pip.textContent = color;

                    const countBadge = document.createElement('div');
                    countBadge.className = 'color-pip-count';
                    countBadge.textContent = count;

                    pip.appendChild(countBadge);
                    elements.colorPips.appendChild(pip);
                }
            });
        }

        // Analyze the current deck
        async function analyzeDeck() {
            if (Object.keys(state.deck.cards).length === 0) {
                showNotification('Please add cards to your deck first', 'error');
                return;
            }

            try {
                // Prepare deck list
                const deckList = [];

                // Add commander if exists
                if (state.deck.commander) {
                    deckList.push(state.deck.commander.name);
                }

                // Add all cards with quantities
                Object.values(state.deck.cards).forEach(card => {
                    for (let i = 0; i < card.quantity; i++) {
                        deckList.push(card.name);
                    }
                });

                // Try to analyze with API
                try {
                    const data = await apiRequest('api.php?action=analyze_deck', {
                        method: 'POST',
                        body: JSON.stringify({ deck: deckList })
                    });

                    if (data && !data.error) {
                        // Update synergy score
                        if (data.average_synergy) {
                            elements.synergyScore.textContent = Math.round(data.average_synergy * 100);
                        }

                        // Display analysis results
                        displayDeckAnalysis(data);
                        return;
                    }
                } catch (error) {
                    console.warn('Failed to analyze deck with API:', error);
                }

                // If we get here, API failed
                throw new Error('Could not analyze deck with API');
            } catch (error) {
                console.error('Error analyzing deck:', error);
                showNotification('Failed to analyze deck. Using demo analysis.', 'error');
                displayDemoAnalysis();
            }
        }

        // Display demo analysis when API fails
        function displayDemoAnalysis() {
            // Create a mock analysis result
            const mockAnalysis = {
                deck_size: Object.values(state.deck.cards).reduce((sum, card) => sum + card.quantity, 0) + (state.deck.commander ? 1 : 0),
                average_synergy: 0.65,
                synergy_count: 15,
                top_synergies: [
                    {
                        card1_name: state.selectedCard ? state.selectedCard.name : "Card 1",
                        card2_name: Object.values(state.deck.cards)[0]?.name || "Card 2",
                        synergy_score: 0.85
                    },
                    {
                        card1_name: Object.values(state.deck.cards)[1]?.name || "Card 3",
                        card2_name: Object.values(state.deck.cards)[2]?.name || "Card 4",
                        synergy_score: 0.75
                    },
                    {
                        card1_name: Object.values(state.deck.cards)[3]?.name || "Card 5",
                        card2_name: Object.values(state.deck.cards)[4]?.name || "Card 6",
                        synergy_score: 0.65
                    }
                ],
                suggestions: [
                    {
                        id: 's1',
                        name: "Lightning Bolt",
                        type_line: "Instant",
                        synergy_with: { [state.selectedCard?.name || "Card 1"]: 0.9, [Object.values(state.deck.cards)[0]?.name || "Card 2"]: 0.8 }
                    },
                    {
                        id: 's2',
                        name: "Counterspell",
                        type_line: "Instant",
                        synergy_with: { [Object.values(state.deck.cards)[1]?.name || "Card 3"]: 0.85, [Object.values(state.deck.cards)[2]?.name || "Card 4"]: 0.75 }
                    },
                    {
                        id: 's3',
                        name: "Sol Ring",
                        type_line: "Artifact",
                        synergy_with: { [Object.values(state.deck.cards)[3]?.name || "Card 5"]: 0.8, [Object.values(state.deck.cards)[4]?.name || "Card 6"]: 0.7 }
                    }
                ]
            };

            // Update synergy score
            elements.synergyScore.textContent = Math.round(mockAnalysis.average_synergy * 100);

            // Display the analysis
            displayDeckAnalysis(mockAnalysis);
        }

        // Display deck analysis results
        function displayDeckAnalysis(analysis) {
            // Create modal for analysis results
            const modal = document.createElement('div');
            modal.className = 'loading-overlay';
            modal.style.display = 'flex';
            modal.style.flexDirection = 'column';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';

            const modalContent = document.createElement('div');
            modalContent.style.background = 'rgba(26, 26, 26, 0.95)';
            modalContent.style.padding = '30px';
            modalContent.style.borderRadius = '10px';
            modalContent.style.maxWidth = '800px';
            modalContent.style.maxHeight = '80vh';
            modalContent.style.overflow = 'auto';
            modalContent.style.position = 'relative';

            // Close button
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '×';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '10px';
            closeBtn.style.right = '10px';
            closeBtn.style.background = 'none';
            closeBtn.style.border = 'none';
            closeBtn.style.color = 'white';
            closeBtn.style.fontSize = '24px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.addEventListener('click', () => document.body.removeChild(modal));

            // Title
            const title = document.createElement('h2');
            title.textContent = 'Deck Analysis';
            title.style.marginBottom = '20px';
            title.style.color = 'white';

            // Overall stats
            const stats = document.createElement('div');
            stats.style.marginBottom = '30px';
            stats.style.padding = '15px';
            stats.style.background = 'rgba(10, 10, 10, 0.5)';
            stats.style.borderRadius = '5px';

            stats.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <div>Total Cards:</div>
                    <div>${analysis.deck_size}</div>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <div>Average Synergy:</div>
                    <div>${Math.round(analysis.average_synergy * 100)}%</div>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <div>Synergy Pairs:</div>
                    <div>${analysis.synergy_count}</div>
                </div>
            `;

            // Top synergies
            const synergiesTitle = document.createElement('h3');
            synergiesTitle.textContent = 'Top Synergies';
            synergiesTitle.style.marginBottom = '15px';
            synergiesTitle.style.color = 'white';

            const synergiesList = document.createElement('div');
            synergiesList.style.marginBottom = '30px';

            if (analysis.top_synergies && analysis.top_synergies.length > 0) {
                analysis.top_synergies.slice(0, 10).forEach(synergy => {
                    const synergyItem = document.createElement('div');
                    synergyItem.style.display = 'flex';
                    synergyItem.style.justifyContent = 'space-between';
                    synergyItem.style.padding = '10px';
                    synergyItem.style.marginBottom = '5px';
                    synergyItem.style.background = 'rgba(10, 10, 10, 0.5)';
                    synergyItem.style.borderRadius = '5px';

                    const pairName = document.createElement('div');
                    pairName.textContent = `${synergy.card1_name} + ${synergy.card2_name}`;

                    const pairScore = document.createElement('div');
                    pairScore.textContent = `${Math.round(synergy.synergy_score * 100)}%`;
                    pairScore.style.color = 'var(--forge-orange)';
                    pairScore.style.fontWeight = 'bold';

                    synergyItem.appendChild(pairName);
                    synergyItem.appendChild(pairScore);
                    synergiesList.appendChild(synergyItem);
                });
            } else {
                synergiesList.innerHTML = '<p>No synergies found.</p>';
            }

            // Suggestions
            const suggestionsTitle = document.createElement('h3');
            suggestionsTitle.textContent = 'Suggested Cards';
            suggestionsTitle.style.marginBottom = '15px';
            suggestionsTitle.style.color = 'white';

            const suggestionsList = document.createElement('div');
            suggestionsList.style.display = 'grid';
            suggestionsList.style.gridTemplateColumns = 'repeat(auto-fill, minmax(200px, 1fr))';
            suggestionsList.style.gap = '15px';

            if (analysis.suggestions && analysis.suggestions.length > 0) {
                analysis.suggestions.forEach(suggestion => {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.style.padding = '15px';
                    suggestionItem.style.background = 'rgba(10, 10, 10, 0.5)';
                    suggestionItem.style.borderRadius = '5px';

                    const suggestionName = document.createElement('div');
                    suggestionName.textContent = suggestion.name;
                    suggestionName.style.fontWeight = 'bold';
                    suggestionName.style.marginBottom = '5px';

                    const suggestionType = document.createElement('div');
                    suggestionType.textContent = suggestion.type_line || '';
                    suggestionType.style.fontSize = '0.8rem';
                    suggestionType.style.opacity = '0.7';
                    suggestionType.style.marginBottom = '10px';

                    // Get synergy with cards
                    const synergyWith = Object.entries(suggestion.synergy_with || {})
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 2)
                        .map(([card, score]) => `${card} (${Math.round(score * 100)}%)`)
                        .join(', ');

                    const suggestionSynergy = document.createElement('div');
                    suggestionSynergy.textContent = `Synergizes with: ${synergyWith}`;
                    suggestionSynergy.style.fontSize = '0.8rem';
                    suggestionSynergy.style.marginBottom = '10px';

                    const addButton = document.createElement('button');
                    addButton.textContent = 'Add to Deck';
                    addButton.style.width = '100%';
                    addButton.style.padding = '8px 0';
                    addButton.style.background = 'var(--forge-red)';
                    addButton.style.border = 'none';
                    addButton.style.borderRadius = '3px';
                    addButton.style.color = 'white';
                    addButton.style.cursor = 'pointer';

                    addButton.addEventListener('click', () => {
                        addCardToDeck({
                            id: suggestion.id || `suggestion_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            name: suggestion.name,
                            type_line: suggestion.type_line || '',
                            cmc: 0 // We don't have CMC in the suggestion data
                        });

                        showNotification(`Added ${suggestion.name} to deck`, 'success');
                    });

                    suggestionItem.appendChild(suggestionName);
                    suggestionItem.appendChild(suggestionType);
                    suggestionItem.appendChild(suggestionSynergy);
                    suggestionItem.appendChild(addButton);

                    suggestionsList.appendChild(suggestionItem);
                });
            } else {
                suggestionsList.innerHTML = '<p>No suggestions available.</p>';
            }

            // Assemble modal
            modalContent.appendChild(closeBtn);
            modalContent.appendChild(title);
            modalContent.appendChild(stats);
            modalContent.appendChild(synergiesTitle);
            modalContent.appendChild(synergiesList);
            modalContent.appendChild(suggestionsTitle);
            modalContent.appendChild(suggestionsList);

            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close on click outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }

        // Save the current deck
        function saveDeck() {
            if (Object.keys(state.deck.cards).length === 0 && !state.deck.commander) {
                showNotification('Cannot save an empty deck', 'error');
                return;
            }

            // Get deck name
            const deckName = state.deck.name || document.getElementById('deck-name').value;

            if (!deckName) {
                showNotification('Please enter a deck name', 'error');
                return;
            }

            // Prepare deck data
            const deckData = {
                name: deckName,
                format: state.deck.format,
                commander: state.deck.commander,
                cards: state.deck.cards,
                created: new Date().toISOString()
            };

            // Save to localStorage
            try {
                // Get existing decks
                const savedDecks = JSON.parse(localStorage.getItem('forgeDecks') || '[]');

                // Add new deck
                savedDecks.push(deckData);

                // Save back to localStorage
                localStorage.setItem('forgeDecks', JSON.stringify(savedDecks));

                showNotification(`Deck "${deckName}" saved successfully!`, 'success');
            } catch (error) {
                console.error('Error saving deck:', error);
                showNotification('Failed to save deck: ' + error.message, 'error');
            }
        }

        // Clear the current deck
        function clearDeck() {
            if (Object.keys(state.deck.cards).length === 0 && !state.deck.commander) {
                showNotification('Deck is already empty', 'info');
                return;
            }

            if (confirm('Are you sure you want to clear your deck?')) {
                state.deck.cards = {};
                state.deck.commander = null;
                updateDeckDisplay();
                showNotification('Deck cleared', 'info');
            }
        }

        // Show a notification
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;

            // Icon based on type
            let icon = '✓';
            if (type === 'error') icon = '✕';
            if (type === 'info') icon = 'ℹ';

            // Create notification content
            notification.innerHTML = `
                <div class="notification-icon">${icon}</div>
                <div class="notification-content">${message}</div>
                <button class="notification-close">×</button>
            `;

            // Add to container
            elements.notificationContainer.appendChild(notification);

            // Add close button functionality
            const closeBtn = notification.querySelector('.notification-close');
            closeBtn.addEventListener('click', () => {
                notification.classList.add('fade-out');
                setTimeout(() => {
                    if (elements.notificationContainer.contains(notification)) {
                        elements.notificationContainer.removeChild(notification);
                    }
                }, 300);
            });

            // Auto-remove after delay
            setTimeout(() => {
                if (elements.notificationContainer.contains(notification)) {
                    notification.classList.add('fade-out');
                    setTimeout(() => {
                        if (elements.notificationContainer.contains(notification)) {
                            elements.notificationContainer.removeChild(notification);
                        }
                    }, 300);
                }
            }, 5000);
        }

        // Enhanced setLoading function with debug info
        function setLoading(isLoading) {
            const prevState = state.loading;
            state.loading = isLoading;
            elements.loadingOverlay.style.display = isLoading ? 'flex' : 'none';

            // Log state change
            console.log(`Loading state changed: ${prevState} -> ${isLoading}`);

            // Clear any existing timeout
            if (window.loadingTimeoutId) {
                clearTimeout(window.loadingTimeoutId);
                window.loadingTimeoutId = null;
            }

            // Set a new timeout if loading is true
            if (isLoading) {
                console.log('Setting loading timeout...');
                window.loadingTimeoutId = setTimeout(() => {
                    // Force hide loading overlay after 15 seconds
                    if (state.loading) {
                        console.warn('Loading timeout reached. Forcing loading state to false.');
                        state.loading = false;
                        elements.loadingOverlay.style.display = 'none';
                        showNotification('Loading timed out. Please try again.', 'error');
                    }
                }, 15000); // 15 seconds timeout
            }
        }


    </script>
</body>

</html>